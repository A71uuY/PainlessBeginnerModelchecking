Basic notations like **Transition system**, **Traces** will be included here, refers to the first 3 chapters in the book.

# Transition system

## Why model checking

Suppose we have a system, the usual way to check the correctness is software or hardware testing performed by human. The first problem is it usually cannot cover all possibilities so potential but fatal errors may occur, which is unacceptable in some domains. The second problem is human can make mistakes (also happen in other checking methods).
Model checking in this book means we use a model to represent a system then check if it have or vaiolate some properties. The advantage is it ensures correctness as long as we have correct model and specifications towards it.

## Transition system

**Transition system** (TS) is frequently used to model a system. We define Transition System as a tuple $(S,Act,I,\rightarrow,AP,L)$ in which $S$ is the set of states, $Act$ is the set of possible actions of the system, $\rightarrow:S \times Act \times S$ is the transition from a state to another state by an action, $I$ is the initial states, $AP$ is the set of atomic propositions that uses logic propositions to describe some facts, $L:S \rightarrow 2^{AP}$ is labelling function that uses the combination to describe 'what is true' in a state.

For instance, if we have a Beverage Machine, we can insert coins, select 'soda' or 'beer', and we can take drinks away, then we can model $S=\{pay, select, soda, beer\}$, $Act=\{insert\_coin, get\_soda, get\_beer, \tau \}$, $I=\{pay\}$, $AP=\{drink, paid\}$. The transitions are shown as arrows in this figure2-1, and for labels, we have $L(pay)=\emptyset, ~L(soda)=L(beer)=\{paid, drink\}, ~L(select)=\{paid\}$ in which $paid$ means 'user already paid', and $drink$ means 'drink is served by the machine'.
![fig2-1](https://user-images.githubusercontent.com/40670333/191696291-e52f4928-f4a7-4a7b-a64b-a2612bde58eb.png)

Notice that by the transition we can define the predecessors ($Pre$) or successors ($Post$) of a state. By keep applying the $Post$ to states from initial states, we can generate an execution $\rho = s_0a_0s_1a_1...$. Intuitively, it's what happens if we keep performing actions in the system.

If we just take the states out, we call $\pi = s_0s_1...$ a path, and if we take the labels out from the path, we get $trace(\pi)=L(s_0)L(s_1)...$ which is called a trace.

If we take all of the possible traces out from a transition system, we got $traces(TS)$ which is useful for checking the properties of a transition system. For example, we can check if some proposition never occur in the possible traces.

## Linear-time Property

A **linear-time property** (LT Property) over a set of atomic propositions is a subset of $(2^{AP})^\omega$. You may notice that if we take an infinite trace, the form looks the same. Actually that's how we check property for a TS. 

Here is one of the most important thing, how to check if a TS satisfy a LT property. We say $TS \vDash P$ iff $Traces(TS) \subseteq P$ where $Traces(TS)$ is the set of all possible traces generated by TS, and $P \subseteq (2^{AP})^\omega$ is the LT property. If all possible traces are in the set $P$, we say the system satisfy the property.

Let's see an example, the left and middle pic of figure3-7 are two traffic lights, and the right part is the synchronization of them, a TS.
![fig3-7](https://user-images.githubusercontent.com/40670333/191707965-8ca33aaa-3cc7-481c-af20-12fe86dd6546.png)

For the TS, we have $AP=\{red_1,red_2,green_1,green_2\}$ describe the colors of two lights.
What we want is checking 'if the first light can be infinitely often green', so this property is the set of all words with infinitely many $g_1$. In this system, the answer should be yes.

## Summary

Transition system has states, actions, atomic propositions, labels, transitions. We excute from the initial states then we got an execution, and taking states generates paths. A linear time property consists of all possible words with some property, and the link between property and transition system is the trace. We take the labels of the states in path then we got a sequence of symbols, we call it a trace. By checking if the system can have a trace that is NOT in a property, we can check if the system satisfies some property.
